from .natural_module import NaturalModule

class IntegerModule:
    def __init__(self, b: int, n: int, A: list):
        self.b = b  # знак числа (1 - минус, 0 - плюс)
        self.n = n  # номер старшей позиции
        self.A = A  # массив цифр

    def ABS_Z_Z(self):
        """
        Овчаренко 4384

        Алгоритм: для положительных чисел и нуля возвращаем само число, для отрицательных - меняем знак на плюс.
        """
        if self.b:
            self.b = 0
        return self

    def POZ_Z_D(self) -> int:
        """
        Овчаренко 4384

        Алгоритм: проверяем, является ли число нулем (все цифры равны 0), затем смотрим знак.
        """
        # Проверяем, является ли число нулем
        is_zero = True
        for el in self.A:
            if el != 0:
                is_zero = False
                break

        if is_zero:
            return 0
        elif self.b:
            return -1
        else:
            return 1

    def MUL_ZM_Z(self):
        """
        Овчаренко 4384

        Алгоритм: меняем знак числа на противоположный.
        Если число было положительным - становится отрицательным и наоборот.
        Если число является нулём - возвращаем само число.
        """
        # Проверяем, является ли число нулем
        is_zero = True
        for el in self.A:
            if el != 0:
                is_zero = False
                break

        if not is_zero:
            self.b = 1 - self.b
        return self

    def TRANS_N_Z(self, n: int, A: list):
        """
        Овчаренко 4384

        Натуральное число становится неотрицательным целым с тем же массивом цифр.
        Принимает на вход:
            n: номер старшей позиции натурального числа
            A: массив цифр натурального числа
        """
        self.b = 0
        self.n = n
        self.A = A
        return self

    def TRANS_Z_N(self) -> NaturalModule:
        """
        Овчаренко 4384

        Алгоритм: проверяем, что число неотрицательное, затем возвращаем его цифровое представление без знака.
        """
        if self.b:
            raise ValueError("Отрицательное число не подходит для преобразования в натуральное")
        return NaturalModule(self.n, self.A)
    
    def ADD_ZZ_Z(self, other):
        """
        Водолазко 4384
        
        Сложение целых чисел.
        Алгоритм основан на анализе знаков слагаемых и выполнении соответствующих операций над модулями.
        
        Принимаемые значения: другое целое число (other)
        Возвращает: результат сложения двух целых чисел
        """
        # Определяем знаки чисел с помощью функции POZ_Z_D()
        # POZ_Z_D возвращает: 0 - если число равно нулю, 1 - если положительное, -1 - если отрицательное
        sign_a = self.POZ_Z_D()  # знак первого числа (self)
        sign_b = other.POZ_Z_D()  # знак второго числа (other)
        
        # Если одно из чисел равно нулю, возвращаем другое число (сложение с нулем)
        if sign_a == 0:  # если первое число равно нулю
            return other  # результат сложения равен второму числу
        if sign_b == 0:  # если второе число равно нулю
            return self   # результат сложения равен первому числу
        
        # Получаем натуральные модули чисел (абсолютные значения)
        # ABS_Z_Z() - получает модуль целого числа (возвращает целое число без знака)
        # TRANS_Z_N() - преобразует целое число в натуральное
        abs_a = self.ABS_Z_Z().TRANS_Z_N()  # модуль первого числа в виде натурального числа
        abs_b = other.ABS_Z_Z().TRANS_Z_N()  # модуль второго числа в виде натурального числа
        
        # Оба числа положительные: выполняем сложение модулей, результат положительный
        if sign_a == 1 and sign_b == 1:
            result_abs = abs_a.ADD_NN_N(abs_b)  # складываем модули как натуральные числа
            return IntegerModule(0, result_abs.n, result_abs.A)  # возвращаем результат с положительным знаком (0)
        
        # Оба числа отрицательные: выполняем сложение модулей, результат отрицательный  
        if sign_a == -1 and sign_b == -1:
            result_abs = abs_a.ADD_NN_N(abs_b)  # складываем модули как натуральные числа
            return IntegerModule(1, result_abs.n, result_abs.A)  # возвращаем результат с отрицательным знаком (1)
        
        # Числа разных знаков: выполняем вычитание модулей
        comparison = abs_a.COM_NN_D(abs_b)  # сравниваем модули чисел (0 - равны, 1 - первое меньше, 2 - первое больше)

        # Модули равны - результат ноль (положительное и отрицательное число с одинаковым модулем)
        if comparison == 0:
            return IntegerModule(0, 0, [0])  # возвращаем ноль
        
        # Модуль первого числа больше: вычитаем из первого модуля второй модуль
        elif comparison == 2:
            result_abs = abs_a.SUB_NN_N(abs_b)  # вычитаем модули: |a| - |b|
            # Результат имеет знак первого числа
            if sign_a == 1:  # если первое число положительное, а второе отрицательное
                return IntegerModule(0, result_abs.n, result_abs.A)  # результат положительный
            else:  # если первое число отрицательное, а второе положительное
                return IntegerModule(1, result_abs.n, result_abs.A)  # результат отрицательный
        
        # Модуль второго числа больше: вычитаем из второго модуля первый модуль
        else:  # comparison == 1
            result_abs = abs_b.SUB_NN_N(abs_a)  # вычитаем модули: |b| - |a|
            # Результат имеет знак второго числа
            if sign_b == 1:  # если второе число положительное, а первое отрицательное
                return IntegerModule(0, result_abs.n, result_abs.A)  # результат положительный
            else:  # если второе число отрицательное, а первое положительное
                return IntegerModule(1, result_abs.n, result_abs.A)  # результат отрицательный

    def SUB_ZZ_Z(self, other):
        """
        Водолазко 4384
        
        Вычитание целых чисел.
        Основано на алгебраическом свойстве: a - b = a + (-b).
        
        Принимаемые значения: другое целое число (other)
        Возвращает: результат вычитания (self - other)
        """
        # Вычитание это сложение с противоположным числом: a - b = a + (-b)
        negative_other = other.MUL_ZM_Z()  # Получаем -other (умножаем на -1)
        return self.ADD_ZZ_Z(negative_other)  # Возвращаем self + (-other)

    def MUL_ZZ_Z(self, other):
        """
        Водолазко 4384
        
        Умножение целых чисел.
        Алгоритм: умножаем модули чисел и определяем знак результата по правилу знаков.
        
        Принимаемые значения: другое целое число (other)
        Возвращает: результат умножения двух целых чисел
        """
        # Определяем знаки множителей
        sign_self = self.POZ_Z_D()  # знак первого множителя
        sign_other = other.POZ_Z_D()  # знак второго множителя
        
        # Если одно из чисел равно нулю, результат - ноль (умножение на ноль)
        if sign_self == 0 or sign_other == 0:
            return IntegerModule(0, 0, [0])  # возвращаем ноль
        
        # Получаем модули чисел (абсолютные значения)
        # ABS_Z_Z() - получает модуль целого числа (убирает знак)
        # TRANS_Z_N() - преобразует целое число в натуральное
        abs_self = (self.ABS_Z_Z()).TRANS_Z_N()  # модуль первого числа
        abs_other = (other.ABS_Z_Z()).TRANS_Z_N()  # модуль второго числа
        
        # Умножаем модули (натуральные числа)
        abs_self.MUL_NN_N(abs_other)  # умножение натуральных чисел (результат сохраняется в abs_self)
        abs_result = NaturalModule(abs_self.n, abs_self.A)  # создаем новый объект натурального числа с результатом
        
        # Создаем целое число с результатом (пока положительное)
        result = IntegerModule(0, abs_result.n, abs_result.A)  # создаем целое число с положительным знаком
        
        # Определяем знак результата по правилу знаков:
        # (+) * (+) = (+), (-) * (-) = (+), (+) * (-) = (-), (-) * (+) = (-)
        if (sign_self == -1 and sign_other == 1) or (sign_self == 1 and sign_other == -1):
            # Если знаки разные, результат отрицательный
            result = result.MUL_ZM_Z()  # умножаем результат на -1 (меняем знак)
        
        return result  # возвращаем итоговый результат

    def DIV_ZZ_Z(self, other):
        """
        Водолазко 4384
        
        Целочисленное деление целых чисел.
        Алгоритм учитывает знаки чисел и правила округления при целочисленном делении.
        
        Принимаемые значения: другое целое число (other)
        Возвращает: неполное частное (целочисленный результат деления)
        """
        # Проверка деления на ноль - основное исключение в арифметике
        if other.POZ_Z_D() == 0:
            raise Exception("Деление на ноль запрещено")

        # Определяем знаки делимого и делителя
        sign_a = self.POZ_Z_D()  # знак делимого (0 - ноль, 1 - положительное, -1 - отрицательное)
        sign_b = other.POZ_Z_D()  # знак делителя

        # Если делимое равно нулю, результат тоже ноль (ноль делится на любое число)
        if sign_a == 0:
            return IntegerModule(0, 0, [0])  # возвращаем ноль

        # Получаем натуральные модули чисел (создаем копии, чтобы не изменять исходные объекты)
        abs_a = NaturalModule(self.n, self.A.copy())  # модуль делимого как натуральное число
        abs_b = NaturalModule(other.n, other.A.copy())  # модуль делителя как натуральное число

        # Сравниваем модули чисел для определения отношения их величин
        comparison = abs_a.COM_NN_D(abs_b)  # 0 - модули равны, 1 - первый модуль меньше, 2 - первый модуль больше

        # Если модуль делимого меньше модуля делителя
        if comparison == 1:
            # Результат будет 0, 1 или -1 в зависимости от комбинации знаков
            if sign_a == 1 and sign_b == 1:
                # Оба положительные: положительное / положительное = 0 (например, 2 / 5 = 0)
                return IntegerModule(0, 0, [0])  
            elif sign_a == 1 and sign_b == -1:
                # Положительное / отрицательное = 0 (например, 2 / -5 = 0)
                return IntegerModule(1, 0, [0])  
            elif sign_a == -1 and sign_b == 1:
                # Отрицательное / положительное = -1 (округление в меньшую сторону, например, -2 / 5 = -1)
                return IntegerModule(1, 0, [1])  # -1
            else:  # оба отрицательные
                # Отрицательное / отрицательное = 1 (округление в большую сторону, например, -2 / -5 = 1)
                return IntegerModule(0, 0, [1])  # 1
        else:
            # Модуль делимого больше или равен модулю делителя
            # Вычисляем частное модулей (натуральное деление)
            q0 = NaturalModule(abs_a.n, abs_a.A.copy())  # создаем копию модуля делимого
            q0.DIV_NN_N(abs_b)  # выполняем натуральное деление: q0 = abs_a // abs_b

            # Вычисляем остаток от деления модулей для проверки точности деления
            product = NaturalModule(abs_b.n, abs_b.A.copy())  # создаем копию модуля делителя
            product.MUL_NN_N(q0)  # умножаем делитель на частное: product = abs_b * q0
            r0 = NaturalModule(abs_a.n, abs_a.A.copy())  # создаем копию модуля делимого
            r0.SUB_NN_N(product)  # вычисляем остаток: r0 = abs_a - (abs_b * q0)

            # Проверяем, равен ли остаток нулю (деление нацело)
            is_zero_remainder = (r0.n == 0 and r0.A[0] == 0)

            # Определяем знак результата и корректируем частное в зависимости от комбинации знаков
            if sign_a == 1 and sign_b == 1:
                # Оба положительные - результат положительный
                result_sign = 0  # положительный знак
                q_result = q0  # частное без изменений
            elif sign_a == 1 and sign_b == -1:
                # Делимое положительное, делитель отрицательный - результат отрицательный
                result_sign = 1  # отрицательный знак
                q_result = q0  # частное без изменений
            elif sign_a == -1 and sign_b == 1:
                # Делимое отрицательное, делитель положительный
                if is_zero_remainder:
                    # Деление нацело - результат отрицательный
                    result_sign = 1  # отрицательный знак
                    q_result = q0  # частное без изменений
                else:
                    # Есть остаток - увеличиваем частное на 1 и делаем отрицательным
                    # (целочисленное деление с округлением в меньшую сторону)
                    result_sign = 1  # отрицательный знак
                    one = NaturalModule(0, [1])  # создаем натуральное число 1
                    q_result = NaturalModule(q0.n, q0.A.copy())  # создаем копию частного
                    q_result.ADD_NN_N(one)  # увеличиваем частное на 1: q_result = q0 + 1
            else:
                # Оба отрицательные
                if is_zero_remainder:
                    # Деление нацело - результат положительный
                    result_sign = 0  # положительный знак
                    q_result = q0  # частное без изменений
                else:
                    # Есть остаток - увеличиваем частное на 1 и делаем положительным
                    # (целочисленное деление с округлением в большую сторону)
                    result_sign = 0  # положительный знак
                    one = NaturalModule(0, [1])  # создаем натуральное число 1
                    q_result = NaturalModule(q0.n, q0.A.copy())  # создаем копию частного
                    q_result.ADD_NN_N(one)  # увеличиваем частное на 1: q_result = q0 + 1

            # Если частное равно нулю, устанавливаем положительный знак
            # (отрицательный ноль не имеет смысла в целых числах)
            if q_result.n == 0 and q_result.A[0] == 0:
                result_sign = 0  # принудительно устанавливаем положительный знак для нуля

            # Возвращаем результат в виде целого числа
            return IntegerModule(result_sign, q_result.n, q_result.A)

    def MOD_ZZ_Z(self, other):
        """
        Водолазко 4384
        
        Вычисление остатка от деления целых чисел.
        Основано на формуле: остаток = делимое - (делитель * частное).
        
        Принимаемые значения: другое целое число (other)
        Возвращает: остаток от деления self на other
        """
        # Создаем копию делимого, чтобы не изменять исходный объект
        a = IntegerModule(self.b, self.n, self.A)
        
        # Проверка деления на ноль - основное исключение
        if other.POZ_Z_D() == 0:
            raise Exception("Деление на ноль")

        # Вычисляем неполное частное (целочисленное деление)
        q = self.DIV_ZZ_Z(other)

        # Вычисляем произведение делителя на частное: other * q
        product = other.MUL_ZZ_Z(q)

        # Вычисляем остаток как разность: self - (other * q)
        # Формула: remainder = dividend - (divisor * quotient)
        remainder = a.SUB_ZZ_Z(product)

        # Возвращаем остаток от деления
        return remainder

    def __str__(self) -> str:
        """
        Водолазко 4384

        Метод вывода строкого представления целого числа
        """
        res = ""
        if self.b and self.A != [0]:
            res += "-"
        for i in self.A[::-1]:
            res += str(i)

        return res
