class NaturalModule:

    def __init__(self, n: int, A: list):
        """
        Инициализация натурального числа.

        Параметры:
        n (int): номер старшей позиции
        A (list): массив цифр
        """
        self.n = n  # Индекс старшей цифры
        self.A = A  # Массив цифр от младшей к старшей
    
    def COM_NN_D(self, other):
        """
        N-1: Сравнение натуральных чисел
        Баневич 4384

        Принимает на вход: другое натуральное число (other)
        Возвращает: 2 - если первое больше, 0 - равны, 1 - второе больше
        """
        # Сравниваем количество цифр (если разное, сразу определяем больше/меньше)
        if self.n > other.n:
            return 2  # У первого числа больше разрядов
        elif self.n < other.n:
            return 1  # У второго числа больше разрядов
        
        # Если одинаковое количество цифр, сравниваем поразрядно от старшей
        for i in range(self.n, -1, -1):  # Идём от старшей цифры к младшей
            if self.A[i] > other.A[i]:
                return 2  # Цифра первого числа больше
            elif self.A[i] < other.A[i]:
                return 1  # Цифра второго числа больше
        return 0  # Все цифры равны - числа равны
    
    def NZER_N_B(self):
        """
        N-2: Проверка на ноль
        Баневич 4384

        Возвращает: False если число равно нулю, True иначе
        """
        # Проверяем условие нуля: n=0 и единственная цифра равна 0
        if self.n == 0 and self.A[0] == 0:
            return False  # Число равно нулю
        return True  # Число не ноль
    
    def ADD_1N_N(self):
        """
        N-3: Добавление 1 к натуральному числу
        Баневич 4384

        Добавляет 1 к текущему натуральному числу.
        Возвращает: self (изменённый объект)
        """
        carry = 1  # Начинаем с переноса 1 (это и есть прибавляемая единица)
        
        # Проходим от младшей цифры с переносом
        for i in range(self.n + 1):  # Проходим все разряды числа
            self.A[i] += carry  # Прибавляем перенос к текущей цифре
            if self.A[i] < 10:  # Если получилось меньше 10 - перенос не нужен
                carry = 0  # Перенос исчерпан
                break  # Выходим из цикла
            else:  # Если получилось 10 или больше
                self.A[i] = 0  # Записываем 0 в текущий разряд
                carry = 1  # Переносим 1 в следующий разряд
        
        # Если остался перенос, добавляем новую цифру (число переходит в новый разряд)
        if carry == 1:
            self.A.append(1)  # Добавляем единицу в старший разряд
            self.n += 1  # Увеличиваем индекс старшего разряда
        return self

    def MUL_ND_N(self, d: int):
        """
        N-6: Умножение натурального числа на цифру
        Баневич 4384

        Принимает на вход: d - цифра (0-9)
        Возвращает: self (изменённый объект)
        """
        # Особый случай: умножение на 0
        if d == 0:
            self.n = 0  # Результат - число из одной цифры
            self.A = [0]  # Результат = 0
            return self
        
        new_A = []  # Новый массив для результата
        carry = 0  # Перенос в старший разряд
        
        # Умножаем каждую цифру на d с учётом переноса
        for i in range(self.n + 1):  # Проходим все цифры числа
            temp = self.A[i] * d + carry  # Умножаем цифру на d и добавляем перенос
            new_A.append(temp % 10)  # Берём младшую цифру результата
            carry = temp // 10  # Старшие цифры идут в перенос
        
        # Если остался перенос, добавляем его как новые разряды
        while carry > 0:  # Пока есть цифры в переносе
            new_A.append(carry % 10)  # Добавляем младшую цифру переноса
            carry = carry // 10  # Убираем обработанную цифру
        
        self.A = new_A  # Записываем результат
        self.n = len(new_A) - 1  # Обновляем индекс старшей позиции
        return self

    def MUL_Nk_N(self, k: int):
        """
        N-7: Умножение натурального числа на 10^k
        Баневич 4384

        Принимает на вход: k - степень десятки
        Возвращает: self (изменённый объект)
        """
        # Если число 0, результат не меняется
        if self.n == 0 and self.A[0] == 0:
            return self
        
        # Умножение на 10^k = добавление k нулей справа (в начало массива A)
        self.A = [0] * k + self.A  # Добавляем k нулей в младшие разряды
        self.n = self.n + k  # Увеличиваем индекс старшей позиции на k
        
        return self

    def ADD_NN_N(self, other):
        """
        N-4: Сложение натуральных чисел
        Баневич 4384

        Принимает на вход: другое натуральное число (other)
        Возвращает: self (изменённый объект)
        """
        result_A = []  # Массив для результата
        carry = 0  # Перенос
        max_len = max(self.n, other.n) + 1  # Максимальная длина + 1 на случай переноса
        
        # Складываем цифры с учётом переноса
        for i in range(max_len):  # Проходим все разряды
            # Берём цифры (если разряд есть) или 0 (если разряда нет)
            digit1 = self.A[i] if i <= self.n else 0
            digit2 = other.A[i] if i <= other.n else 0
            temp = digit1 + digit2 + carry  # Складываем цифры и перенос
            result_A.append(temp % 10)  # Записываем младшую цифру суммы
            carry = temp // 10  # Вычисляем перенос в следующий разряд
        
        # Если последний перенос, добавляем его
        if carry:
            result_A.append(carry)  # Добавляем перенос как новый старший разряд
        
        self.A = result_A  # Записываем результат
        self.n = len(result_A) - 1  # Обновляем индекс старшей позиции
        return self

    def SUB_NN_N(self, other):
        """
        N-5: Вычитание из натурального другого натурального
        Баневич 4384

        Принимает на вход: другое натуральное число (other)
        Возвращает: self (изменённый объект)
        Предполагается: self >= other
        """
        result_A = []  # Массив для результата
        borrow = 0  # Переменная для заимствования из старшего разряда
        
        for i in range(self.n + 1):  # Проходим все разряды уменьшаемого
            digit1 = self.A[i]  # Берём цифру уменьшаемого
            digit2 = other.A[i] if i <= other.n else 0  # Цифра вычитаемого (или 0)
            temp = digit1 - digit2 - borrow  # Вычитаем с учётом заимствования
            
            # Если результат отрицательный, занимаем 10 из старшей позиции
            if temp < 0:
                temp += 10  # Занимаем 10 из следующего разряда
                borrow = 1  # Запоминаем, что заняли
            else:
                borrow = 0  # Заимствования не было
            
            result_A.append(temp)  # Записываем цифру результата
        
        # Удаляем ведущие нули
        while len(result_A) > 1 and result_A[-1] == 0:
            result_A.pop()  # Убираем старшие нули
        
        self.A = result_A  # Записываем результат
        self.n = len(result_A) - 1  # Обновляем индекс старшей позиции
        return self

    def MUL_NN_N(self, other):
        """
        N-8: Умножение натуральных чисел
        Баневич 4384

        Принимает на вход: другое натуральное число (other)
        Возвращает: self (изменённый объект)

        ВАЖНО:
        - Гарантируем, что self.A и other.A не пустые (минимум [0]).
        - Индекс старшей цифры n всегда согласуем с len(A) - 1.
        """

        # --- 0. Страховка от "битых" чисел -----------------------------------
        # Если массив цифр пуст — трактуем число как 0.
        if not getattr(self, "A", None):
            self.A = [0]
            self.n = 0
        if not getattr(other, "A", None):
            other.A = [0]
            other.n = 0

        # На всякий случай синхронизируем n с длиной массива.
        # Даже если где-то ранее n выставили неправильно, тут мы это исправляем.
        self.n = len(self.A) - 1
        other.n = len(other.A) - 1

        # --- 1. Инициализация результата --------------------------------------
        # Максимальная длина произведения: (len(self.A) + len(other.A))
        # Берём с небольшим запасом (+1) – как и в исходном коде.
        result_len = (self.n + 1) + (other.n + 1)
        result_A = [0] * (result_len + 1)

        # --- 2. Перемножение "в столбик" --------------------------------------
        for i in range(self.n + 1):
            for j in range(other.n + 1):
                # i‑тая цифра self * j‑тая цифра other
                result_A[i + j] += self.A[i] * other.A[j]

        # --- 3. Обработка переносов -------------------------------------------
        for i in range(len(result_A) - 1):
            carry = result_A[i] // 10
            result_A[i] %= 10
            result_A[i + 1] += carry

        # --- 4. Удаление ведущих нулей ----------------------------------------
        # Оставляем хотя бы одну цифру.
        while len(result_A) > 1 and result_A[-1] == 0:
            result_A.pop()

        # --- 5. Запись результата в self --------------------------------------
        self.A = result_A
        self.n = len(result_A) - 1

        return self


    def SUB_NDN_N(self, other, d: int):
        """
        N-9: Вычитание из натурального другого, умноженного на цифру
        Баневич 4384

        Принимает на вход: другое натуральное число (other), цифра d (0-9)
        Возвращает: self (изменённый объект)
        """
        # Создаём временную копию для вычисления other * d
        temp = NaturalModule(other.n, other.A.copy())
        temp.MUL_ND_N(d)  # Умножаем other на d
        
        # Вычитаем результат из self
        self.SUB_NN_N(temp)
        return self

    def DIV_NN_Dk(self, other):
        """
        N-10: Вычисление первой цифры деления большего натурального на меньшее
        Баневич 4384

        Принимает на вход: другое натуральное число (other)
        Возвращает: (d, k) - первая цифра частного и степень 10^k
        """
        k = self.n - other.n  # Разница в количестве разрядов
        
        # Если делимое меньше делителя, частное 0
        if k < 0:
            return (0, 0)

        # Подбираем максимальную цифру d: d * other * 10^k <= self
        for d in range(9, -1, -1):  # Перебираем от 9 до 0
            temp = NaturalModule(other.n, other.A.copy())  # Копируем делитель
            temp.MUL_ND_N(d)  # Умножаем на цифру d
            temp.MUL_Nk_N(k)  # Умножаем на 10^k
            
            # Если temp <= self, нашли нужную цифру
            if temp.COM_NN_D(self) <= 1:  # temp <= self или temp < self
                return (d, k)
        
        return (0, k)  # На случай если ничего не подошло
    
    def DIV_NN_N(self, other):
        """
        N-11: Неполное частное от деления первого натурального на второе
        Баневич 4384

        Принимает на вход: другое натуральное число (other)
        Возвращает: self (изменённый объект) - неполное частное
        """
        quotient_A = []  # Массив для цифр частного
        remainder = NaturalModule(0, [0])  # Остаток, изначально 0
        
        # Алгоритм длинного деления: обрабатываем цифры делимого от старшей
        for i in range(self.n, -1, -1):  # Идём от старшей цифры к младшей
            # Сдвигаем остаток влево и добавляем следующую цифру делимого
            if not (remainder.n == 0 and remainder.A[0] == 0):  # Если остаток не 0
                remainder.MUL_Nk_N(1)  # Сдвигаем влево (умножаем на 10)
            remainder.A[0] = self.A[i]  # Добавляем текущую цифру делимого
            
            # Обновляем индекс старшей позиции остатка
            while len(remainder.A) > 1 and remainder.A[-1] == 0:  # Убираем ведущие нули
                remainder.A.pop()
            remainder.n = len(remainder.A) - 1
            
            # Находим максимальную цифру частного для текущей позиции
            d = 0  # Изначально 0
            for test_d in range(9, -1, -1):  # Перебираем от 9 до 0
                temp = NaturalModule(other.n, other.A.copy())  # Копируем делитель
                temp.MUL_ND_N(test_d)  # Умножаем на test_d
                if temp.COM_NN_D(remainder) != 2:  # Если temp <= remainder
                    d = test_d  # Нашли подходящую цифру
                    break
            
            quotient_A.append(d)  # Добавляем цифру в частное
            
            # Вычитаем d * other из остатка
            if d > 0:  # Если цифра не 0
                temp = NaturalModule(other.n, other.A.copy())  # Копируем делитель
                temp.MUL_ND_N(d)  # Умножаем на d
                remainder.SUB_NN_N(temp)  # Вычитаем из остатка
        
        # Переворачиваем массив цифр частного (собирали в обратном порядке)
        quotient_A.reverse()

        # Удаляем ведущие нули
        while len(quotient_A) > 1 and quotient_A[-1] == 0:
            quotient_A.pop()
        
        self.A = quotient_A  # Записываем результат
        self.n = len(quotient_A) - 1  # Обновляем индекс старшей позиции
        return self

    def MOD_NN_N(self, other):
        """
        N-12: Остаток от деления первого натурального на второе
        Баневич 4384

        Принимает на вход: другое натуральное число (other)
        Возвращает: self (изменённый объект) - остаток
        """
        # Формула: остаток = делимое - (делимое // делитель) * делитель
        quotient = NaturalModule(self.n, self.A.copy())  # Копируем делимое
        quotient.DIV_NN_N(other)  # Вычисляем частное
        
        temp = NaturalModule(quotient.n, quotient.A.copy())  # Копируем частное
        temp.MUL_NN_N(other)  # Умножаем частное на делитель
        
        self.SUB_NN_N(temp)  # Вычитаем из делимого
        return self  # Остаток в self
    
    def GCF_NN_N(self, other):
        """
        N-13: НОД натуральных чисел
        Баневич 4384

        Принимает на вход: другое натуральное число (other)
        Возвращает: self (изменённый объект) - НОД

        Использование в других методах: 1
        """
        # Алгоритм Евклида: НОД(a,b) = НОД(b, a mod b)
        while other.NZER_N_B():  # Пока other не равно 0
            remainder = NaturalModule(self.n, self.A.copy())  # Копируем self
            remainder.MOD_NN_N(other)  # Вычисляем остаток от деления self на other
            
            # Меняем местами: self = other, other = remainder
            self.n = other.n
            self.A = other.A.copy()

            other.n = remainder.n
            other.A = remainder.A.copy()
        
        return self  # В self остался НОД

    def LCM_NN_N(self, other):
        """
        Водолазко 4384

        Принимает на вход: другое натуральное число (other)
        Возвращает: res - НОК
        """
        other_1 = NaturalModule(other.n, other.A)
        # Формула связи НОК и НОД: НОК(a,b) = (a*b)/НОД(a,b)
        temp = NaturalModule(self.n, self.A.copy())
        temp.GCF_NN_N(other)  # temp = НОД(a,b)

        self.MUL_NN_N(other_1)  # self = a * b

        self.DIV_NN_N(temp)  # self = (a*b) / НОД(a,b)

        return self

    def __str__(self):
        return "".join([str(i) for i in self.A])[::-1]
